C++ Arg\+Parse is an open source header-\/only C++ library. Due to the core\textquotesingle{}s heavy usage of template magic, the library can expose a very easy-\/to-\/use interface, so you as an application developer only have to care about the good stuff. Think Python\textquotesingle{}s \href{https://docs.python.org/3/library/argparse.html}{\tt argparse}.

\href{https://travis-ci.org/backraw/cppargparse}{\tt }

{\itshape Support for Windows is currently untested.}

If you want to skip the following example and core presentations, you can do so by going straight to \href{#Build-tests-and-install}{\tt Build tests and install}.

The source code documentation can be found here\+: \href{https://backraw.github.io/cppargparse}{\tt https\+://backraw.\+github.\+io/cppargparse}

\section*{The library interface}

Please have a look at the \href{https://github.com/backraw/cppargparse/tree/master/samples}{\tt examples}.

You can mix \href{https://github.com/backraw/cppargparse/tree/master/samples/traditional}{\tt traditional} and \href{https://github.com/backraw/cppargparse/tree/master/samples/callback}{\tt callback} arguments as you wish. The \href{https://github.com/backraw/cppargparse/blob/master/include/cppargparse/parser.h}{\tt Argument\+Parser} class provides an interface for both and doesn\textquotesingle{}t care which one you chose.

\section*{The core}

All the magic is done via the typed {\ttfamily \hyperlink{structcppargparse_1_1argument}{cppargparse\+::argument}} struct. Each such struct definition {\bfseries must provide 3 static methods}\+:
\begin{DoxyItemize}
\item {\ttfamily T parse(cmd, position, cmdargs)}
\item {\ttfamily T convert(cmd, position, cmdargs)}
\item {\ttfamily const char $\ast$error\+\_\+string(position)}
\end{DoxyItemize}

Parameter definition\+:
\begin{DoxyItemize}
\item {\ttfamily cmd} represents the whole command line inside a {\ttfamily std\+::vector$<$std\+::string$>$}
\item {\ttfamily position} represents the argument iterator position inside {\ttfamily cmd}
\item {\ttfamily cmdargs} represents the command line argument map, e.\+g. {\ttfamily \char`\"{}arg1\char`\"{} =$>$ iterator position 0}
\end{DoxyItemize}

The {\ttfamily \hyperlink{classcppargparse_1_1parser_1_1ArgumentParser}{cppargparse\+::parser\+::\+Argument\+Parser}} class provides the {\ttfamily get\+\_\+option$<$T$>$(arg)}, {\ttfamily get\+\_\+option$<$T$>$(arg, default)} and {\ttfamily get\+\_\+flag(arg)} methods for calling the actual type converter methods provided by the {\ttfamily \hyperlink{structcppargparse_1_1argument}{cppargparse\+::argument}$<$T$>$} structs.

Assume the following command line arguments have been passed\+: {\ttfamily -\/t 3 -\/n \char`\"{}\+My Name\char`\"{} -\/-\/enable} 
\begin{DoxyCode}
\{C++\}
// -t 3
parse<int>(<cmd>, <argument iterator position 0>, <cmdargs>)
// calls and returns the value of
convert<int>(<cmd>, <argument iterator position 1>, <cmdargs>)
// which is the integer 3.


// -n "My Name"
parse<std::string>(<cmd>, <argument iterator position 2>, <cmdargs>)
// calls and returns the value of
convert<std::string>(<cmd>, <argument iterator position 3>, <cmdargs>)
// which is the string "My Name".


// --enable
// flags are checked only for their existence inside <cmd>,
// they don't provide any conversion methods.
\end{DoxyCode}


\subsection*{Primitive numerical types}

Let\textquotesingle{}s look at the {\ttfamily int} type, for example\+: 
\begin{DoxyCode}
\{C++\}
template <>
struct argument<int>
\{
    static int parse(
            const types::CommandLine\_t &,
            const types::CommandLinePosition\_t &position,
            const types::CommandLineArguments\_t &)
    \{
        return numerical\_argument::parse<int>(
            position,
            CPPARGPARSE\_NUMERICAL\_ARGUMENT\_CONVERTER\_OVERLOADS(std::stoi),
            "int"
        );
    \}

    static int convert(
            const types::CommandLine\_t &,
            const types::CommandLinePosition\_t &position,
            const types::CommandLineArguments\_t &)
    \{
        return numerical\_argument::convert<int>(
            position,
            CPPARGPARSE\_NUMERICAL\_ARGUMENT\_CONVERTER\_OVERLOADS(std::stoi),
            "int"
        );
    \}
\};
\end{DoxyCode}


All it does is call {\ttfamily cppargparse\+::numerical\+\_\+argument\+::parse$<$int$>$()} (or {\ttfamily cppargparse\+::numerical\+\_\+argument\+::convert$<$int$>$()}) on a command line argument iterator position {\ttfamily position} and tell the former to use {\ttfamily std\+::stoi} as the conversion function.

{\ttfamily float}, {\ttfamily double}, and {\ttfamily long double} are implemented in the same way, using
\begin{DoxyItemize}
\item {\ttfamily std\+::stof},
\item {\ttfamily std\+::stod} and
\item {\ttfamily std\+::stold}
\end{DoxyItemize}

as conversion functions, respectively.

The {\ttfamily cppargparse\+::numerical\+\_\+argument} namespace provides the actual parser and converter functions\+: 
\begin{DoxyCode}
\{C++\}
template <typename T>
static T convert(
        const types::CommandLinePosition\_t &position,
        const std::function<T(const std::string &, size\_t *)> &numerical\_converter,
        const std::string &type\_string
    )
\{
    try
    \{
        return numerical\_converter(*position, 0);
    \}

    catch (std::invalid\_argument const &)
    \{
        throw errors::CommandLineOptionError(error\_message(position, type\_string));
    \}
    catch (std::out\_of\_range const &)
    \{
        throw errors::CommandLineOptionError(error\_message(position, type\_string));
    \}
\}

template <typename T>
static T parse(const types::CommandLinePosition\_t &position,
        const std::function<T(const std::string &, size\_t *)> &numerical\_converter,
        const std::string &type\_string)
\{
    return convert(std::next(position), numerical\_converter, type\_string);
\}
\end{DoxyCode}


{\ttfamily cppargparse\+::numerical\+\_\+argument\+::convert()} calls {\ttfamily numerical\+\_\+converter} with a string as the argument. {\ttfamily numerical\+\_\+converter} can (currently) be one of the following\+:
\begin{DoxyItemize}
\item {\ttfamily std\+::stoi}
\item {\ttfamily std\+::stof}
\item {\ttfamily std\+::stod}
\item {\ttfamily std\+::stold}
\end{DoxyItemize}

A conversion error is indicated by throwing {\ttfamily errors\+::\+Command\+Line\+Option\+Error} with a custom error message.

{\ttfamily cppargparse\+::numerical\+\_\+argument\+::parse()} calls {\ttfamily cppargparse\+::numerical\+\_\+argument\+::convert()} with the command line argument next in line.

\subsection*{String types}

Currently only {\ttfamily std\+::string} is implemented as a string type\+: 
\begin{DoxyCode}
\{C++\}
static const std::string convert(
        const types::CommandLine\_t &cmd,
        const types::CommandLinePosition\_t &position,
        const types::CommandLineArguments\_t &)
\{
    if (position == cmd.cend())
    \{
        throw errors::CommandLineOptionError(error\_message(position));
    \}

    return *position;
\}
\end{DoxyCode}


It just checks whether the end of the command line argumnents list has been reached. If so, thrown an error, if not, return its string value.

\subsection*{Vector types}

Currently only {\ttfamily std\+::vector$<$T$>$} is implemented as a vector type\+: 
\begin{DoxyCode}
\{C++\}
static const std::vector<T> parse(
        const types::CommandLine\_t &cmd,
        const types::CommandLinePosition\_t &position,
        const types::CommandLineArguments\_t &cmdargs)
\{
    auto positions = get\_option\_positions(cmd, position, cmdargs);
    std::vector<T> values;

    for (auto position : positions)
    \{
        values.emplace\_back(argument<T>::convert(cmd, position, cmdargs));
    \}

    return values;
\}


static types::CommandLinePositions\_t get\_option\_positions(
        const types::CommandLine\_t &cmd,
        const types::CommandLinePosition\_t &position,
        const types::CommandLineArguments\_t &cmdargs)
\{
    types::CommandLinePositions\_t positions;

    for (auto current = std::next(position); current != cmd.end(); ++current)
    \{
        if (algorithm::find\_arg(cmdargs, *current) != cmdargs.cend())
        \{
            break;
        \}

        positions.emplace\_back(current);
    \}

    return positions;
\}
\end{DoxyCode}


It collects all values tied to the argument and converts each value string to {\ttfamily T}.

\subsection*{Custom types}

... todo ...

\section*{Build tests and install}

Build requirements\+:
\begin{DoxyItemize}
\item {\ttfamily gcc}, {\ttfamily clang}, or {\ttfamily msvc}
\item {\ttfamily cmake}
\end{DoxyItemize}

Then you should be able to build the tests like this\+: 
\begin{DoxyCode}
git clone https://github.com/backraw/cppargparse.git
cd cppargparse

mkdir build
cd build

cmake -DCMAKE\_BUILD\_TYPE=Profiling ..
make tests
\end{DoxyCode}


Of course, you can use every generator that C\+Make supports.

To install the library, run {\ttfamily sudo make install} inside the build directory. 